package com.openbexi.timeline.data_browser;

import com.mongodb.MongoException;
import com.mongodb.client.*;
import com.mongodb.client.model.InsertOneOptions;
import org.bson.Document;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

//This class uses OpenAI's GPT models for language processing and has been generated by ChatGPT4.
public class db_mongo_manager extends data_manager {

    private MongoDatabase _database;
    private MongoCollection<Document> _collection;

    public db_mongo_manager(String currentStartDate, String currentEndDate, String search,
                            String filter, String action_type, HttpServletResponse response, HttpSession session, data_configuration configuration) {
        super(response, session, configuration);

        try {
            configuration = new data_configuration("etc/ob_mongodb_test_conf.json");
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ParseException e) {
            throw new RuntimeException(e);
        }
        login(configuration.getUrl(0), configuration.getDatabase(0), configuration.getCollection(0), null);
        get_filter();
    }

    public static void main(String[] args) {
        boolean connected = false;
        String url = null;

        if (args.length == 2) {
            if (args[0].equals("-url")) {
                url = args[1];
                connected = true;
            }
        }

        if (!connected) {
            System.err.println("db_mongo_manager: Not connected to MongoDB because of bad usage:");
            System.err.println("Argument " + args[0] + " " + "-url <path>");
            System.exit(1);
        }

        db_mongo_manager openbexi_mongo = new db_mongo_manager(null, null,
                null, null, null, null, null, null);

    }

    // the login() method below has been created by ChatGPT4 after asking for:
    // Can you provide the java code for the method
    // Object login(String url, String database, String collection, JSONArray cookies) .
    // It is a new method for the db_mongo_manager class which connect to MongoDB and
    // get handle for the private variable "_database" and "_collection" according to the arguments "database" and "collection".
    // please use <dependencies>
    //        <dependency>
    //            <groupId>org.mongodb</groupId>
    //            <artifactId>mongodb-driver-sync</artifactId>
    //            <version>4.5.0</version>
    //        </dependency>
    //    </dependencies>
    // please add javadoc

    @Override
    Object login(String url, JSONArray cookies) {
        return null;
    }

    /**
     * Establishes a connection to a MongoDB database and retrieves handles for the specified
     * database and collection.
     *
     * @param url        the URL of the MongoDB instance to connect to
     * @param database   the name of the database to retrieve a handle for
     * @param collection the name of the collection to retrieve a handle for
     * @param cookies    an optional JSONArray of cookies to use for authentication (not used in this implementation)
     * @return a success message if the connection is established and the handles are retrieved, or an error message
     * if the connection fails
     */
    public Object login(String url, String database, String collection, JSONArray cookies) {
        try {
            // Create a MongoClient instance by connecting to the MongoDB instance at the specified URL
            MongoClient mongoClient = MongoClients.create(url);

            // Get a handle to the specified database
            _database = mongoClient.getDatabase(database);

            // Get a handle to the specified collection
            _collection = _database.getCollection(collection);

            // Return a success message
            return "Successfully connected to MongoDB database " + database + " and collection " + collection;
        } catch (Exception e) {
            // Return an error message if the connection fails
            return "Error connecting to MongoDB: " + e.getMessage();
        }
    }

    private static JSONObject createJsonObjectWithKey(Object key, Object value) {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(key.toString(), value);
        return jsonObject;
    }

    public static JSONArray convertJsonObjectToJsonArray(JSONObject jsonObject) {
        JSONArray jsonArray = new JSONArray();

        for (Object key : jsonObject.keySet()) {
            Object value = jsonObject.get(key);

            if (value instanceof JSONObject) {
                JSONObject nestedObject = (JSONObject) value;
                jsonArray.add(createJsonObjectWithKey(key, convertJsonObjectToJsonArray(nestedObject)));
            } else {
                jsonArray.add(createJsonObjectWithKey(key, value));
            }
        }

        return jsonArray;
    }

    static public JSONObject convertBsonToJson(Document bsonDocument) {
        JSONObject jsonObject = new JSONObject();
        for (String key : bsonDocument.keySet()) {
            Object value = bsonDocument.get(key);
            if (value instanceof Document) {
                jsonObject.put(key, convertBsonToJson((Document) value));
            } else if (value instanceof Iterable) {
                JSONArray jsonArray = new JSONArray();
                for (Object element : (Iterable<?>) value) {
                    if (element instanceof Document) {
                        jsonArray.add(convertBsonToJson((Document) element));
                    } else {
                        jsonArray.add(element);
                    }
                }
                jsonObject.put(key, jsonArray);
            } else {
                jsonObject.put(key, value);
            }
        }
        return jsonObject;
    }

    @Override
    public Object getData(String filter, String ob_scene) {
        JSONArray json_array = null;
        try {
            MongoCursor<Document> cursor = _collection.find().iterator();
            while (cursor.hasNext()) {
                Document doc = cursor.next();
                JSONObject json_object = convertBsonToJson(doc);
                JSONObject json_object2 = (JSONObject) json_object.get("0");
                json_array = convertJsonObjectToJsonArray(json_object2);
            }
        } catch (MongoException e) {
            System.err.println("Error reading data from MongoDB: " + e.getMessage());
        }
        return json_array;
    }

    @Override
    boolean sendData(Object data) {
        return false;
    }

    @Override
    JSONArray filterDates(JSONArray events, long currentEndDate, long currentStartDate) {
        return null;
    }

    @Override
    JSONArray filterEvents(JSONArray events, String filter_include, String filter_exclude) {
        return null;
    }

    @Override
    JSONArray searchEvents(JSONArray events, String search) {
        return null;
    }

    /**
     * Adds the specified events to the MongoDB collection.
     *
     * @param events the JSONArray of events to add to the collection
     * @return true if the events are added successfully, or false if an error occurs
     */
    @Override
    public boolean addEvents(JSONArray events, String ob_scene) {
        try {
            // Convert the JSONArray to a Document object
            Document eventsDoc = jsonArrayToDocument(events);

            // Delete previuos
            _collection.drop();

            // Add the Document to the MongoDB collection
            _collection.insertOne(eventsDoc, new InsertOneOptions());

            // Return true to indicate success
            return true;
        } catch (Exception e) {
            // Print the error message and stack trace to the standard error stream
            System.err.println("Error adding events to MongoDB collection:");
            e.printStackTrace(System.err);

            // Return false to indicate failure
            return false;
        }
    }

    public boolean updateEvents(JSONArray events, String ob_scene) {
        // Update the events in the collection
        for (int i = 0; i < events.size(); i++) {
            // Get the ID of the event to update
            String id = ((org.json.simple.JSONObject) events.get(i)).get("_id").toString();

            // Create a document with the updated event data
            Document updatedEvent = Document.parse(events.get(i).toString());

            // Replace the event in the collection with the updated document
            _collection.replaceOne(new Document("_id", id), updatedEvent);
        }

        return true;
    }

    @Override
    public boolean removeEvents(JSONArray events, String ob_scene) {
        _collection.drop();
        return true;
    }

    @Override
    public Object addFilter(String ob_timeline_name, String ob_title, String ob_scene, String ob_filter_name, String ob_backgroundColor, String ob_user, String ob_email, String ob_top, String ob_left, String ob_width, String ob_height, String ob_camera, String ob_sort_by, String ob_filter) {
        return updateFilter("addFilter", ob_timeline_name, ob_scene, ob_title, ob_filter_name,
                ob_backgroundColor, ob_user, ob_email, ob_top, ob_left, ob_width, ob_height, ob_camera, ob_sort_by,
                ob_filter);
    }

    @Override
    public Object updateFilter(String ob_action, String ob_timeline_name, String ob_scene, String ob_title,
                               String ob_filter_name, String ob_backgroundColor, String ob_user, String ob_email,
                               String ob_top, String ob_left, String ob_width, String ob_height, String ob_camera,
                               String ob_sort_by, String ob_filter) {
        return super.updateFilter(ob_action, ob_timeline_name, ob_scene, ob_title, ob_filter_name, ob_backgroundColor,
                ob_user, ob_email, ob_top, ob_left, ob_width, ob_height, ob_camera, ob_sort_by, ob_filter);
    }

    @Override
    public Object removeFilter(String ob_timeline_name, String ob_filter_name, String ob_scene, String ob_user) {
        return super.removeFilter(ob_timeline_name, ob_filter_name, ob_scene, ob_user);
    }

    @Override
    public boolean removeAllFilter(String ob_timeline_name, String ob_user) {
        return super.removeAllFilter(ob_timeline_name, ob_user);
    }

    @Override
    boolean onDataChange(String ob_scene) throws InterruptedException {
        return false;
    }

    // ChatGPT4 provided the code for the functions:
    //      - jsonArrayToDocument
    //      - jsonObjectToDocument
    //
    //List of questions:
    //Provide a public java code function to convert  JSONArray to MongoDB document.
    //Rewrite the code using import org.json.simple.JSONArray and org.json.simple.JSONObject
    //
    //This code recursively converts nested JSON objects and arrays to MongoDB documents.
    // Note that it assumes that all values in the JSON array are JSON objects.
    // If your input can include other types of values, you may need to add additional type checks or error handling.
    //
    // This code uses the jsonArrayToDocument method to convert a JSONArray to a Document,
    // and the jsonObjectToDocument method to convert a JSONObject to a Document.
    // Both methods use recursion to handle nested JSON objects and arrays.
    public Document jsonArrayToDocument(JSONArray jsonArray) {
        Document document = new Document();
        for (int i = 0; i < jsonArray.size(); i++) {
            Object obj = jsonArray.get(i);
            if (obj instanceof JSONArray) {
                document.append(String.valueOf(i), jsonArrayToDocument((JSONArray) obj));
            } else if (obj instanceof JSONObject) {
                document.append(String.valueOf(i), jsonObjectToDocument((JSONObject) obj));
            } else {
                document.append(String.valueOf(i), obj);
            }
        }
        return document;
    }

    // ChatGPT4 provided the code for documentToJsonArray:

    public Document jsonObjectToDocument(JSONObject jsonObject) {
        Document document = new Document();
        for (Object keyObj : jsonObject.keySet()) {
            String key = (String) keyObj;
            Object value = jsonObject.get(key);
            if (value instanceof JSONArray) {
                document.append(key, jsonArrayToDocument((JSONArray) value));
            } else if (value instanceof JSONObject) {
                document.append(key, jsonObjectToDocument((JSONObject) value));
            } else {
                document.append(key, value);
            }
        }
        return document;
    }

    /**
     * Converts a MongoDB Document object to a JSONArray using the org.json.simple library.
     *
     * @param doc the Document object to convert
     * @return a JSONArray containing the converted data
     */

    public JSONArray documentToJsonArray(Document doc) {
        JSONArray jsonArray = new JSONArray();
        JSONObject jsonObject = new JSONObject(doc);
        jsonArray.add(jsonObject);
        return jsonArray;
    }

    /**
     * Converts a JSON string to a JSONArray using the org.json.simple library.
     *
     * @param jsonString the JSON string to convert
     * @return a JSONArray containing the converted data
     * @throws ParseException if the JSON string cannot be parsed
     */
    public JSONArray jsonStringToJsonArray(String jsonString) throws ParseException {
        JSONParser parser = new JSONParser();
        Object obj = parser.parse(jsonString);
        if (obj instanceof JSONObject) {
            JSONArray jsonArray = new JSONArray();
            jsonArray.add(obj);
            return jsonArray;
        }
        JSONArray jsonArray = (JSONArray) obj;
        return jsonArray;
    }

}

